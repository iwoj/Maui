// =============================================================================// com.bitmovers.utilities.OrderedHashtable// =============================================================================package com.bitmovers.utilities;import java.io.*;import java.util.*;// =============================================================================// CLASS: OrderedHashtable// =============================================================================/** OrderedHashtable is a class than encapsulates the functionality of a Vector   * and a Hashtable. Elements are ordered and may be accessed by index or by a  * key. This class is not as efficient as a Hashtable, although future   * optimizations should bring it much closer to the speed of a regular   * Hashtable.<p>  *   * Note that this class extends Hashtable in anticipation of these  * optimizations, but presently makes no use of its superclass (ie: all   * Hashtable methods are overridden without calling any public or protected   * Hashtable fields).  *  * @author Ian Wojtowicz <ian@bitmovers.com>  * @version 1999.12.03  */public class OrderedHashtable extends Hashtable implements Cloneable, Serializable{	// ---------------------------------------------------------------------------			private Hashtable hashtable;	private Vector keyVector;			// ---------------------------------------------------------------------------	// CONSTRUCTOR	// ---------------------------------------------------------------------------		public OrderedHashtable()	{		this.hashtable = new Hashtable();		this.keyVector = new Vector();	}		public OrderedHashtable(int initialCapacity)	{		this.hashtable = new Hashtable(initialCapacity);		this.keyVector = new Vector(initialCapacity);	}		public OrderedHashtable(int initialCapacity, float loadCapacity)	{		this.hashtable = new Hashtable(initialCapacity, loadCapacity);		this.keyVector = new Vector(initialCapacity);	}		private OrderedHashtable(Hashtable hashtable, Vector keyVector)	{		this.hashtable = hashtable;		this.keyVector = keyVector;	}			// ---------------------------------------------------------------------------	// METHOD: clear	// ---------------------------------------------------------------------------		public synchronized void clear()	{		this.hashtable.clear();		this.keyVector = new Vector();	}			// ---------------------------------------------------------------------------	// METHOD: clone	// ---------------------------------------------------------------------------		public synchronized Object clone()	{		return new OrderedHashtable((Hashtable)this.hashtable.clone(), (Vector)this.keyVector.clone());	}			// ---------------------------------------------------------------------------	// METHOD: contains	// ---------------------------------------------------------------------------		public synchronized boolean contains(Object value)	{		return this.hashtable.contains(value);	}			// ---------------------------------------------------------------------------	// METHOD: contains	// ---------------------------------------------------------------------------		public synchronized boolean containsKey(Object key)	{		return this.hashtable.containsKey(key);	}			// ---------------------------------------------------------------------------	// METHOD: elements	// ---------------------------------------------------------------------------		public synchronized Enumeration elements()	{		return this.new Enumerator();	}			// ---------------------------------------------------------------------------	// METHOD: get	// ---------------------------------------------------------------------------		public synchronized Object get(Object key)	{		return this.hashtable.get(key);	}			// ---------------------------------------------------------------------------	// METHOD: getAt	// ---------------------------------------------------------------------------		public synchronized Object getAt(int index)	{		return this.hashtable.get(this.keyVector.elementAt(index));	}			// ---------------------------------------------------------------------------	// METHOD: indexOf	// ---------------------------------------------------------------------------		public int indexOf(Object key)	{		return this.keyVector.indexOf(key);	}			// ---------------------------------------------------------------------------	// METHOD: isEmpty	// ---------------------------------------------------------------------------		public boolean isEmpty()	{		return this.hashtable.isEmpty();	}			// ---------------------------------------------------------------------------	// METHOD: keys	// ---------------------------------------------------------------------------		public synchronized Enumeration keys()	{		return this.keyVector.elements();	}			// ---------------------------------------------------------------------------	// METHOD: put	// ---------------------------------------------------------------------------		public synchronized Object put(Object key, Object value)	{		if (!this.keyVector.contains(key))		{			this.keyVector.addElement(key);		}		return this.hashtable.put(key, value);	}			// ---------------------------------------------------------------------------	// METHOD: putAt	// ---------------------------------------------------------------------------		public synchronized Object putAt(Object key, Object value, int index)	{		this.keyVector.setElementAt(key, index);		return this.hashtable.put(key, value);	}			// ---------------------------------------------------------------------------	// METHOD: remove	// ---------------------------------------------------------------------------		public synchronized Object remove(Object key)	{		this.keyVector.removeElement(key);		return this.hashtable.remove(key);	}			// ---------------------------------------------------------------------------	// METHOD: removeAt	// ---------------------------------------------------------------------------		public synchronized Object removeAt(int index)	{		Object oldValue = this.hashtable.remove(this.keyVector.elementAt(index));		this.keyVector.removeElementAt(index);		return oldValue;	}			// ---------------------------------------------------------------------------	// METHOD: size	// ---------------------------------------------------------------------------		public int size()	{		return this.hashtable.size();	}			// ---------------------------------------------------------------------------	// METHOD: toString	// ---------------------------------------------------------------------------		public synchronized String toString()	{		return this.hashtable.toString() + " + " + this.keyVector.toString();	}			// ---------------------------------------------------------------------------	// METHOD: rehash	// ---------------------------------------------------------------------------		protected void rehash()	{		// No point in using rehash() until OrderedHashtable is properly integrated		// with its superclass.		//super.rehash();	}				// ---------------------------------------------------------------------------	// INNER CLASS: Enumerator	// ---------------------------------------------------------------------------		/** A hashtable enumerator class to be returned by the elements() method.	  */		private class Enumerator implements Enumeration	{		Hashtable hashtable = OrderedHashtable.this.hashtable;		Vector keyVector = OrderedHashtable.this.keyVector;				private int index = this.keyVector.size();								Enumerator() { }						public boolean hasMoreElements()		{			if (this.index <= 0)			{				return false;			}			else			{				return true;			}		}						public Object nextElement()		{			if (this.index <= 0)			{				throw new NoSuchElementException("OrderedHashtable Enumerator");			}			else			{				return this.hashtable.get(this.keyVector.elementAt(--this.index));			}		}	}			// ---------------------------------------------------------------------------}