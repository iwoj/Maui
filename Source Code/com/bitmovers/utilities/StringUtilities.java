// =============================================================================// com.bitmovers.utilities.StringUtilities// =============================================================================package com.bitmovers.utilities;import java.util.*;// =============================================================================// CLASS: StringUtilities// =============================================================================/** StringUtilities is a cool class.  All of the methods in this class are   * static.  You can't really instantiate the class.  Use it like a swiss   * army knife, instead (don't cut yourself).  *	  * @author Various Artists (variousartists@bitmovers.com)  * @version 1999.11.03  */public class StringUtilities{	// ---------------------------------------------------------------------------      // In case you cut yourself with this swiss army knife.  public String forEmergencyUseOnly = "Band Aid";      // ---------------------------------------------------------------------------  // METHOD: split  // ---------------------------------------------------------------------------	public static Vector split(String delimiterString, String originalString)	{		StringTokenizer st = new StringTokenizer(originalString, delimiterString);		Vector stringVector = new Vector();		while (st.hasMoreTokens())		{			stringVector.addElement(st.nextToken());		}		return stringVector;	}	  // ---------------------------------------------------------------------------  // METHOD: join  // ---------------------------------------------------------------------------		public static String join(String delimiterString, Vector originalVector)	{		if (originalVector != null && !originalVector.isEmpty())		{			StringBuffer returnValue = new StringBuffer((String)originalVector.firstElement());			for (int i = 1; i < originalVector.size(); i++)			{				returnValue.append(delimiterString + (String)originalVector.elementAt(i));			}			return returnValue.toString();		}		else		{			return "";		}	}		  // ---------------------------------------------------------------------------  // METHOD: chop  // ---------------------------------------------------------------------------		/** This method returns the given string with the last character removed.    *    * @param originalString The string to chop.    */    	public static String chop(String originalString)	{		return chop(originalString, 1);	}		/** This method returns the given string with the specified number of 	  * character removed from the end.    *    * @param originalString The string to chop.    * @param chopSize The number of characters to chop.    */    	public static String chop(String originalString, int chopSize)	{		return originalString.substring(0, originalString.length() - chopSize);	}		  // ---------------------------------------------------------------------------  // METHOD: crop  // ---------------------------------------------------------------------------		/** This method returns the given string with the first character removed.    *    * @param originalString The string to crop.    */    	public static String crop(String originalString)	{		return crop(originalString, 1);	}		/** This method returns the given string with the specified number of 	  * character removed from the beginning.    *    * @param originalString The string to chop.    * @param chopSize The number of characters to chop.    */    	public static String crop(String originalString, int cropSize)	{		//old:return originalString.substring(cropSize);		//new lines on Nov 8, 2000		String returnSubString; 		if (originalString.length() > 35) 		  {  		    returnSubString = originalString.substring(0,cropSize);		  } 		else		  {   		    returnSubString = originalString.substring(cropSize);		  }		return returnSubString;		//new lines -END    	}		  // ---------------------------------------------------------------------------  // METHOD: replace  // ---------------------------------------------------------------------------	public static String replace( String searchString, String replaceString, String originalString )	{		Vector tempVector;		tempVector = split( searchString, originalString );		return join( replaceString, tempVector );	}  // ---------------------------------------------------------------------------  // METHOD: createNonNullList  // ---------------------------------------------------------------------------  /** This method adds a non-null and non-zero-length string to a list using    * an optionally specified delimiter.<p>    *    * @param list The list to add an item to.    * @param item The item to add to the list.    * @param delimiter An optional delimiter (comma, by default)    */  public static String createNonNullList(String list, String item)  {    return createNonNullList(list, item, ", ");  }    public static String createNonNullList(String list, String item, String delimiter)  {    if ((item == null) || (item.length() == 0))    {      return list;    }    if (list == null)    {      list = "";    }		if (list.length() == 0)		{		  list += item;		}		else		{			list += delimiter + item;		}				return list;  }  // ---------------------------------------------------------------------------  // METHOD: killNull  // ---------------------------------------------------------------------------  /** This method tests a String for a null value. If it's null, it returns    * ""; otherwise it returns the original String.      *    * @param string The String to test for a null value.    */  public static String killNull(String string)  {    if (string == null)    {      return "";    }    else    {      return string;    }  }  // ---------------------------------------------------------------------------  // METHOD: killEmpty  // ---------------------------------------------------------------------------  /** replaces the null/empty String with the specified word (but only if it's    * null or empty).    */      public static String killEmpty(String string, String returnString)  {    if (string == null)    {      return returnString;    }    else    {      if (string.equals(""))      {        return returnString;      }      else      {        return string;      }    }  }  // ---------------------------------------------------------------------------  // METHOD: capitalise  // ---------------------------------------------------------------------------	public static String capitalise(String originalString)	{    Vector items = split(" ", originalString);        for (int i = 0; i < items.size(); i++)    {      String wordString = (String)(items.elementAt(i));            {	      char firstCharacter = wordString.charAt(0);	      String newWordString = Character.toUpperCase(firstCharacter) + wordString.substring(1, wordString.length());        items.setElementAt(newWordString, i);      }    }        return join(" ", items);	}  // -----------------------------------------------------------------------  // METHOD: escapeSingleQuotes  // -----------------------------------------------------------------------    /** This method escapes any single quotes in a given string. (intended for  	* SQL statements)  	*/  	public static String escapeSingleQuotes(String string)	{	  return StringUtilities.replaceCharacter(string, "'", "\\'");	}  // -----------------------------------------------------------------------  // METHOD: replaceCharacter  // -----------------------------------------------------------------------	/** This method replaces one string with another.		*		* @param string The string to perform the search and replace on.		* @param before The string to search for.		* @param after The string to replace with.		*		* @deprecated - use replaceString().		*/	public static String replaceCharacter(String string, String before, String after)	{		return com.bitmovers.utilities.StringUtilities.replaceString(string, before, after);	}  // -----------------------------------------------------------------------  // METHOD: replaceString  // -----------------------------------------------------------------------	/** This method replaces one string with another.		*		* @param string The string to perform the search and replace on.		* @param before The string to search for.		* @param after The string to replace with.		*/	public static String replaceString(String string, String before, String after)	{	  String returnString = "";	  	  int index = 0;	  int lastIndex = 0;	  int counter = 0;	  	  try	  {	    while (index != -1)	    {				// Make the search case insenstive, and get the index of the first match.				index = string.toLowerCase().indexOf(before.toLowerCase(), lastIndex);				// CASE: match found	      if (index != -1)	      {          returnString += string.substring(lastIndex, index) + after;          lastIndex = index + before.length();        }				// CASE: there are no more matches left        else if ((counter != 0) && (index == -1))        {          returnString += string.substring(lastIndex, string.length());        }        // CASE: there are no matches at all        else if ((counter == 0) && (index == -1))        {          throw new Exception();        }				// Incremement the counter        counter++;      }	  }	  catch (Exception e)    {	    returnString = string;    }	  finally	  {	    return returnString;	  }	}  // -----------------------------------------------------------------------  // METHOD: highlightString  // -----------------------------------------------------------------------	/** highlightString adds a prefix and suffix to a String found within a	  * source String. It is most useful in an HTML context, but is certainly	  * not limited to it. Example:	  *	  * <pre>	  *  String string = "The quick brown fox jumps over the lazy dog.";	  *	  *  string = highlightString(string, "fox", "<u>", "</u>");	  * </pre>	  *	  * This would search for all occurances of the word "fox" and underline	  * each of those matches.		*		* @param source - The source String to perform the search (and replace) on.		* @param searchString - The String to search for.		* @param prefix - The String to prepend to the matched word.		* @param suffix - The String to append to the matched word.		*		*/	public static String highlightString(String source, String searchString, String prefix, String suffix)	{	  String returnString = "";	  	  int index = 0;	  int lastIndex = 0;	  int counter = 0;	  	  try	  {	    while (index != -1)	    {				// Make the search case insenstive, and get the index of the first match.				index = source.toLowerCase().indexOf(searchString.toLowerCase(), lastIndex);				// CASE: match found	      if (index != -1)	      {          returnString += source.substring(lastIndex, index);          returnString += prefix;          returnString += source.substring(index, index + searchString.length());          returnString += suffix;                    lastIndex = index + searchString.length();        }				// CASE: there are no more matches left        else if ((counter != 0) && (index == -1))        {          returnString += source.substring(lastIndex, source.length());        }        // CASE: there are no matches at all        else if ((counter == 0) && (index == -1))        {          throw new Exception();        }				// Incremement the counter        counter++;      }	  }	  catch (Exception e)    {	    returnString = source;    }	  finally	  {	    return returnString;	  }	}  // ---------------------------------------------------------------------------  // METHOD: wordWrap  // ---------------------------------------------------------------------------	/** wordWrap takes a String and wraps it to a given width using a given new	  * line character.	  *	  * (*) Note: This method actually wraps at the beginning of the closest word	  * at the given width. For example, if you wrap to 42 characters, and that	  * happens to be in the middle of the word, the method will try to wrap where	  * that word started. If the word is too long to do that nicely, it will chop	  * it in two.	  *	  * @param stringToWrap - The String you wish to wrap (input).	  * @param maximumCharactersPerLine - Number of characters per line to wrap	  * to. (int)	  *	  * @return the wrapped String	  *	  */  public static String wordWrap(String stringToWrap, int MAXIMUM_CHARACTERS)  {		return com.bitmovers.utilities.StringUtilities.wordWrap(stringToWrap, "\n", MAXIMUM_CHARACTERS);	}  // ---------------------------------------------------------------------------  // METHOD: wordWrap  // ---------------------------------------------------------------------------	/** wordWrap takes a String and wraps it to a given width using a given new	  * line character.	  *	  * (*) Note: This method actually wraps at the beginning of the closest word	  * at the given width. For example, if you wrap to 42 characters, and that	  * happens to be in the middle of the word, the method will try to wrap where	  * that word started. If the word is too long to do that nicely, it will chop	  * it in two.	  *	  * @param stringToWrap - The String you wish to wrap (input).	  * @param newLineCharacter - The String to use as a new line character.	  * @param maximumCharactersPerLine - Number of characters per line to wrap	  * to. (int)	  *	  * @return the wrapped String	  *	  */  public static String wordWrap(String stringToWrap, String newLineCharacter, int MAXIMUM_CHARACTERS)  {    String returnString = "";                // resulting string after processing    char[] testChar;                         // test character for isWhitespace() method    int toIndex = MAXIMUM_CHARACTERS;        // the location of the whitespace    boolean isWhitespace = false;            // tester variable    // handle null strings    if (stringToWrap == null)    {      return "";    }    while (stringToWrap.length() > 0)    {      testChar = stringToWrap.toCharArray();      try      {        if (stringToWrap.length() > MAXIMUM_CHARACTERS)        {          while (!isWhitespace)          {            isWhitespace = Character.isWhitespace(testChar[toIndex]);            if (isWhitespace)            {              throw new Exception("WHITESPACE");            }            else            {              if (toIndex <= 0)              {                throw new Exception("LONGSTRING");              }              else              {                toIndex--;              }            }          }        }        else        {          returnString += stringToWrap;          stringToWrap = "";        }      }      catch (Exception e)      {        if (e.getMessage().equals("LONGSTRING"))        {          // if the string is a LONGSTRING (> max), we will just chop it          toIndex = MAXIMUM_CHARACTERS;        }      }             try      {        // here we are going to handle unexpected \n's and \r's        if ((stringToWrap.indexOf("\n") != -1) && (stringToWrap.indexOf("\n") <= MAXIMUM_CHARACTERS))        {          toIndex = stringToWrap.indexOf("\n");          returnString += stringToWrap.substring(0, toIndex + 1) + newLineCharacter;        }        else if ((stringToWrap.indexOf("\r") != -1) && (stringToWrap.indexOf("\r") <= MAXIMUM_CHARACTERS))        {          toIndex = stringToWrap.indexOf("\r");          returnString += stringToWrap.substring(0, toIndex + 1);        }        else        {          returnString += stringToWrap.substring(0, toIndex + 1) + newLineCharacter;        }        // cut the current line out of the provided string for the next loop        stringToWrap = stringToWrap.substring(toIndex + 1, stringToWrap.length());               // reset our tester variables        isWhitespace = false;        toIndex = MAXIMUM_CHARACTERS;      }      catch (StringIndexOutOfBoundsException e)      {        // do nothing      }    }    return returnString;  }   // ---------------------------------------------------------------------------  // METHOD: detectHTML  // ---------------------------------------------------------------------------  /** detectHTML searches a string for signs of HTML. If any html is found in    * the string is will return a boolean true. If no html is found it will    * return a boolean false.	  *	  * @param stringToSearch - The String you wish to Search.	  *	  * @return boolean true if html was found, false if not html found.	  */  public static Boolean detectHTML(String stringToSearch)  {    // search for a < character in the string    int indexOfLT = stringToSearch.indexOf('<');    // check the index of the character, if -1 , the character doesn't exist.    if (indexOfLT == -1)    {      return new Boolean(false); // no HTML was detected.    }    else    {      // check if the > character is after the < sign, if so then chances are we have html, if not, then no html exists.      int indexOfGT = stringToSearch.indexOf('>');      if (indexOfGT < indexOfLT)      {        return new Boolean(false); // no HTML exists.      }      else      {        // check for starting of HTML tags, since there is chance that HTML exists in the string.        stringToSearch = stringToSearch.toLowerCase();        if (stringToSearch.indexOf("<a") != -1 || stringToSearch.indexOf("<img") != -1 || stringToSearch.indexOf("<p") != -1 || stringToSearch.indexOf("<b") != -1 || stringToSearch.indexOf("<font") != -1 || stringToSearch.indexOf("<h") != -1 || stringToSearch.indexOf("<t") != -1 || stringToSearch.indexOf("<strong") != -1 || stringToSearch.indexOf("<e") != -1 || stringToSearch.indexOf("<u") != -1 || stringToSearch.indexOf("<div") != -1 || stringToSearch.indexOf("<i") != -1)        {          return new Boolean(true); // html was detected.        }        else        {          return new Boolean(false); // no html was detected.        }      }          }      }	  // ---------------------------------------------------------------------------}// =============================================================================// Copyright (c) 1999 Bitmovers Communications Inc.                          eof